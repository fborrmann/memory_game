<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE bookarticlearticlearticlearticle PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "../docbook-xml-4.5/docbookx.dtd">
<article>
  <articleinfo>
    <title>Dokumentation zum Praktikum XML-Technologie</title>
        
    <author>
      <firstname>Group</firstname>
      <surname>XSLT</surname>
      <affiliation>
      </affiliation>
    </author>
   </articleinfo>

	  	<sect1><title>Gliederung und Beschreibung der Ansichten</title>
	      Das Spiel ist logisch in 2 Ebenen unterteilt. Zunächst eine 
	      Lounge-Ansicht, in der Spielern offene Spiele angezeigt werden, sowie eine Highscore-Liste.
	      Die Lounge bietet die Möglichkeit, ein neues Spiel zu starten oder ein gespeichertes
	      Spiel fortzusetzen. Beim Start eines neuen Spiels, kann der Spieler auswählen, mit wie vielen Karten,
	      und Personen er spielen möchte. Jedem Mitspieler kann zudem ein Name gegeben werden.
	      Sobald ein Spiel gestartet wurde, wird die zweite Ebene, ein Spielfeld mit der gewünschten Kartenanzahl
	      angezeigt, wobei die Karten zu beginn alle verdeckt liegen, wenn es sich um ein neu gestartetes Spiel handelt. Zudem werden
	      die Spieler mit ihren aktuellen Punkten angezeigt, wobei der aktuelle Spieler farblich hervorgehoben ist.
	      Das Spiel kann zu jedem Zeitpunkt unterbrochen werden. Dabei kehrt das Spiel wieder in
	      die Lounge-Ansicht zurück. Das Spiel ist beendet, sobald alle Karten mit ihrem Bild nach oben liegen.
	      Daraufhin wird anstelle der Karten das Ergebnis des Spiels angezeigt.
	    </sect1>

	    <sect1><title> Elemente eines Spiels</title>
		  In der Spiele-Umgebung sind mehrere Elemente situationsabhängig und müssen damit definierte Zustände besitzen.
		  Dies sind zunächst die Spiel-Karten. Ihre beiden Zustände sind verdeckt und offen. Ihre Anzahl und damit ihre Position auf
		  dem Spielfeld muss zudem parametrisch beschrieben werden.
		  Auch die Anzeige des aktuellen Spielers muss durch Zustände beschrieben werden. Ein Spieler kann an der Reihe sein oder nicht.
		  Weiterhin ist die Anzahl der Spieler, sowie deren Punktestand parametrisch vorzuhalten.
		  Zuletzt muss der Spielstand mit Zustandsdaten beschrieben werden. Dies beeinhaltet die Info, wie viele Karten bereits aufgedeckt wurden.
		  Abhängig davon wird der Zustand definiert, ob das Spiel gespielt wird, oder ob es beendet ist, da alle Karten aufgedeckt wurden.
		  Auch die Funktionen speichern und abbrechen gehören zum Spiel, welche die Zustände des Spiels verändern.
		    <figure><title>Klassendiagramm zum Spiel</title>
		        <imageobject>
		            <imagedata scale="60" fileref="input/images/class_diagram.png"/>
		        </imageobject>
		    </figure>
	    </sect1>
	    
	    <sect1><title>Speicherung Spieldaten in Datenbanken</title>
		Für die Speicherung der Daten werden in BaseX zwei Datenbanken angelegt: &quot;XSLT&quot;, welches die Informationen über die erzeugten Spiele speichert und &quot;XSLT_highscores&quot; in welcher die Daten zur Bestenliste zu finden sind. Diese Trennung ist keine Notwendigkeit für die gegebene Implementierung, sondern soll rein zur logischen Trennung der Daten dienen. Eine logische Trennung der Daten ist sinnvoll, speziell wenn das Programm in der Zukfunft erweitert oder modifiziert wird. Anfangs müssen beide Dantebanken mittels entsprechenden XML-Dateien initialisiert werden, welche weitestgehend aus einem leeren Wurzelknoten bestehen. Wird anschließend in der Anwendung ein neues Spiel erzeugt, so wird dieses mittels der XQuery Update Facility (bereitgestellt durch BaseX) als neuer Knoten in der XSLT Datenbank eingefügt. Auf ähnliche Weise erfolgt die Speicherung der Ergebnisse in der Bestenliste. Da diese jedoch nur die besten zehn Ergebnisse speichern soll, muss geprüft werden, ob ein Ergebniss in die Liste aufgenommen werden soll und ob dabei ein bestehender Wert verdrängt wird. Die entsprechende Logik wird in der Funktion &quot;g:insertHighsScores&quot;, sowie deren Hilfsfunktion &quot;g:updateHighScores&quot; umgesetzt, welche sich selbst der XQUF bedient um zunächst die alten Werte aus der Datenbank zu löschen und anschließend die neue Liste zurückzuschreiben.
	  	</sect1>
	  		    
	    <sect1><title>View - Erstellung HTML Nodes mit XSLT</title>
		Konzeptionell lässt sich das Spiel in zwei Bereiche einteilen: Zum einen existiert die Lobby, in der die Highscore-Liste zu finden ist, neue Spiele erstellt und alte Spiele geladen werden können. Zum anderen gibt es die Darstellung für das Memory-Spiel selbst, mitsamt der Karten und dem User-Interface. Diese  Zweiteilung lässt sich in ähnlicher Weise auch in der Implementierung wiederfinden, wobei jedoch Unterschiede in der jeweiligen Umsetzung bestehen. Der statische Teil der Lobby liegt direkt als Datei(&quot;Lobby.xml&quot;) vor, und nutzt RestXQ um die übrigen Elemente einzufügen (Highscoreliste, Liste der gespeicherten Spiele). Auch wird die Instanz des XForms-Modell mittels RestXQ erzeugt. Für die Darstellung eines aktiven Spiels wird hingegen ein anderer Ansatz verfolgt, welcher sich auf XSL Transformationen stützt um aus den Spieldaten die aktuelle Sicht zu erzeugen. Da diese Umsetzung alle nötigen Informationen aus der Datenbank und der Session-ID bezieht, lässt sich das Laden und Speichern eines Spiels damit mit wenig zusätzlichem Aufwand realisieren. Um aus den Daten die Ausgabe mittels eines XSL Stylesheets zu erzeugen wird die Funktion &quot;xslt:transform($input, $stylesheet)&quot; auf die XML Daten angewendet. Diese verwendet als Default den Xalan Prozessor für die Transformationen, bzw. den Saxxon Prozessor, falls verfügbar. Mittels des hier verwendete Stylesheet(&quot;svg_creator.xsl&quot;) erzeugt dieser Prozessor das XHTML Dokument (inklusive XForms-Modell und Kontrollen), welches dem Nutzer anschließend durch den Browser als aktuelle Sicht angezeigt wird. Da XSLT unter anderem Schleifen unterstützt, lässt sich auf diese Weise eine eindeutige Submission für jede Karte erzeugen, aufgrund derer übermittelt wird, welche Karte vom Spieler selektiert wurde. Mittels &quot;xsl:choose&quot; kann eine Fallunterscheidung getroffen werden, um beispielsweise zu entscheiden, welche Seite einer Karte angezeigt werden soll. Auch die finale Zusammenfassung der Spiels, inklusive der Bekanntgabe der Gewinner erfogt mittels des Stylesheets. Die Neu-Erzeugung des Dokuments bringt für das Memory-Projekt einige Vorteile mit sich und zeigt akzeptable Performanz. Für größere Projekte sollten jedoch weitere Optimierungen vorgenommen werden oder ein anderer Ansatz verfolgt werden, um ausreichend schnell auf Nutzer-Eingaben reagieren zu können.
	  	</sect1>
	  	
	  	<sect1><title>Controller - Kommunikation Client/Server</title>
	  	</sect1>	  	
	  	<sect1><title>Model - Interne Funktionen</title>
	  		<para>Erstellen neues Spiel - newGameXML()  
			</para>
	  		<para>Anzeige Spiele - ListSavedGames()  
			</para>
	  		<para>Anzeige Highscores - HighScoreList()  
			</para>
	  		<para>Spiellogik - flipCard(): 
		  	  Ein Spieler klickt nacheinander 2 Karten an, die jeweils aufgedeckt werden.
		      Haben die gewählten Karten nicht das gleiche Bild, werden sie wieder umgedreht und der nächste Spieler ist
		      an der Reihe. Sind beide Karten gleich, werden die Karten aus dem Spielfeld entfernt.
		      In diesem Fall wird die Punkteanzahl für den aktuellen Spieler um 1 nach oben gesetzt und er darf weiter machen.
		      Sobald er kein passendes Paar an Karten aufdeckt, ist der nächste Spieler an der Reihe.
			</para>
	  	</sect1>

 

</article>
